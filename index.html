<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="node_modules/opencv.js/opencv.js"></script>
    <script src="node_modules/fabric/dist/fabric.js"></script>
    <script src="scripts/grabcut.js"></script>
    <script src="scripts/rectangle.js"></script>
    <script src="scripts/lines.js"></script>
    <title>Prototype</title>
</head>

<body>
    <h1>Prototype</h1>
    <input type="file" id="file_input">
    <button id="rect" onclick="changeButton('rect')">Rectangle</button>
    <button id="green" onclick="changeButton('green')">Green Line</button>
    <button id="red" onclick="changeButton('red')">Red Line</button>
    <button id="brush width">Brush Width</button>
    <div>
        <h2>Input</h2>
        <canvas id="input"></canvas>
    </div>
    <div>
        <h2>Extracted</h2>
        <canvas id="extracted"></canvas>
    </div>
    <script>
        // create fabric wrappers around canvases
        const input = new fabric.Canvas('input');
        // global state variables
        let cv_image; // cv.Mat image cache
        let result; // result of grabcut operations
        let extracted; // individual extraction result
        // file upload logic
        const file_input = document.getElementById('file_input');
        let image = document.createElement('img');
        file_input.onchange = (e) => {
            // clear canvas of any existing objects
            input.clear();
            // load the file
            image.src = URL.createObjectURL(e.target.files[0]);
            image.onload = _ => {
                input.setDimensions({ width: image.width, height: image.height });
                const fabric_image = new fabric.Image(image);
                input.setBackgroundImage(
                    fabric_image,
                    _ => {
                        input.renderAll();
                        cv_image = cv.imread(image);
                        cv.cvtColor(cv_image, cv_image, cv.COLOR_RGBA2RGB);
                        extracted = new cv.Mat.zeros(image.height, image.width, cv.CV_8UC1);
                        cv.imshow("extracted", extracted);
                    }
                );
            }
        }
        //show button value
        function changeButton(value) {
            input.__eventListeners = {} // TODO: Fix, hacky
            if (value == 'rect') {
                console.log("Here!")
                input.isDrawingMode = false;
                input.on("mouse:down", startRect);
                input.on("mouse:up", endRect);
            } else {
                input.isDrawingMode = true;
                const circleBrush = new fabric.PencilBrush(input);
                circleBrush.width = 3;
                circleBrush.color = value;
                input.freeDrawingBrush = circleBrush;
                input.on("mouse:up", _ => {
                    // step 1: extract out points
                    const points = circleBrush._points;
                    // step 2: draw points onto mask
                    const pixel_value = new cv.Scalar(value == 'green' ? cv.GC_FGD : cv.GC_BGD);
                    console.log(pixel_value);
                    for (let i = 0; i < points.length - 1; i++) {
                        const start = points[i];
                        const end = points[i + 1];
                        cv.line(result.mask, start, end, pixel_value);
                    }
                    // step 3: invoke mask grabcut
                    result = maskGrabCut(
                        cv_image,
                        result.mask,
                        result.bgdModel,
                        result.fgdModel
                    );
                    // step 4: render the results
                    const fg_points = extractMaskPoints(result.mask, isForeground);
                    updateMask(result.mask, fg_points, 255);
                    cv.imshow("extracted", result.mask);
                });
            }
        }
    </script>
</body>

</html>